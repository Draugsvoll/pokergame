// Generated by CoffeeScript 2.5.1
(function() {
  // DOM HOOKS #
  // buttons
  var Player, announcementText, betRaise, bet_raise_btn, board, boardCard1, boardCard2, boardCard3, boardCard4, boardCard5, button_bar, checkCall, check_call_btn, clearBets, currentStreet, dealCards, dealFlop, dealNextStreet, dealRiver, dealTurn, deck, defaultStackSize, emptyTableForAnnouncementText, endHand, fold_btn, getHandStrength, getKicker, getNewDeck, handRank, handTracker, hasFlush, hasRankedBasedHand, hasStraight, hero, heroCard1DOM, heroCard2DOM, heroCards, heroCardsInteger, heroFold, heroIsDealer, heroStack, heroStrength, hero_current_action, hero_current_bet, hero_dealer, hero_image, historyBox, new_hand_btn, p, potDOM, potSize, renderBets, renderButtons, renderDealerBtn, renderEmptyHeroCards, renderEmptyTableGraphics, renderEmptyVillainCards, renderHandSrengths, renderHeroBetText, renderHeroCallText, renderHeroCheckText, renderPlayerCards, renderPot, renderResetFlop, renderStacks, renderVillainBetText, renderVillainCallText, renderVillainCheckText, renderVillainFoldText, startHand, table_logo, villain, villainAct, villainActing, villainCard1DOM, villainCard2DOM, villainCards, villainCardsInteger, villainCreateAndMakeBet, villainFold, villainStack, villainStrength, villain_current_bet, villain_dealer, villain_image;

  button_bar = document.querySelector('.button-bar');

  fold_btn = document.querySelector(".fold");

  check_call_btn = document.querySelector(".check-call");

  bet_raise_btn = document.querySelector(".bet-raise");

  new_hand_btn = document.querySelector(".new-hand-btn");

  // table graphics
  hero_current_bet = document.querySelector(".hero-current-bet");

  hero_current_action = document.querySelector(".hero-current-action");

  potDOM = document.querySelector('.pot');

  hero_dealer = document.querySelector(".hero-dealer");

  heroStrength = document.querySelector('.hero-strength');

  heroStack = document.querySelector('.hero-stack');

  hero_dealer = document.querySelector(".hero-dealer");

  villain_dealer = document.querySelector(".villain-dealer");

  villain_current_bet = document.querySelector(".villain-current-bet");

  villainStack = document.querySelector('.villain-stack');

  villainCard1DOM = document.querySelector('#villain-card1');

  villainCard2DOM = document.querySelector('#villain-card2');

  villainStrength = document.querySelector('.villain-strength');

  villainActing = document.querySelector(".villain-acting");

  announcementText = document.querySelector(".table-text");

  historyBox = document.getElementById('history');

  table_logo = document.getElementById('table-logo');

  // cards
  heroCard1DOM = document.querySelector('#hero-card1');

  heroCard2DOM = document.querySelector('#hero-card2');

  boardCard1 = document.querySelector('#board-card1');

  boardCard2 = document.querySelector('#board-card2');

  boardCard3 = document.querySelector('#board-card3');

  boardCard4 = document.querySelector('#board-card4');

  boardCard5 = document.querySelector('#board-card5');

  // avatars
  hero_image = document.querySelector("#hero-image");

  villain_image = document.querySelector("#villain-image");

  // variables
  currentStreet = 0;

  defaultStackSize = 4000;

  heroIsDealer = true;

  board = [];

  // need both string/integer for hand strengths
  heroCards = [];

  heroCardsInteger = [];

  villainCardsInteger = [];

  villainCards = [];

  potSize = 0;

  announcementText.innerHTML = '<br> The Poker Lounge';

  announcementText.style.visibility = 'visible';

  villainStrength.style.display = "none";

  villainStrength.style.visibility = "hidden";

  button_bar.style.visibility = 'hidden';

  villain_dealer.style.visibility = "hidden";

  villain_dealer.style.visibility = "hidden";

  handTracker = 0;

  p = document.createElement("p");

  p.innerHTML = '-- Welcome to the Poker Lounge --';

  p.classList.add('history-text', 'welcome-text');

  historyBox.append(p);

  // CREATE CARD DECK
  getNewDeck = function() {
    var myNewDeck;
    myNewDeck = [
      {
        value: '2H',
        rank: 2
      },
      {
        value: '3H',
        rank: 3
      },
      {
        value: '4H',
        rank: 4
      },
      {
        value: '5H',
        rank: 5
      },
      {
        value: '6H',
        rank: 6
      },
      {
        value: '7H',
        rank: 7
      },
      {
        value: '8H',
        rank: 8
      },
      {
        value: '9H',
        rank: 9
      },
      {
        value: '0H',
        rank: 10
      },
      {
        value: 'JH',
        rank: 11
      },
      {
        value: 'QH',
        rank: 12
      },
      {
        value: 'KH',
        rank: 13
      },
      {
        value: 'AH',
        rank: 14
      },
      {
        value: '2C',
        rank: 2
      },
      {
        value: '3C',
        rank: 3
      },
      {
        value: '4C',
        rank: 4
      },
      {
        value: '5C',
        rank: 5
      },
      {
        value: '6C',
        rank: 6
      },
      {
        value: '7C',
        rank: 7
      },
      {
        value: '8C',
        rank: 8
      },
      {
        value: '9C',
        rank: 9
      },
      {
        value: '0C',
        rank: 10
      },
      {
        value: 'JC',
        rank: 11
      },
      {
        value: 'QC',
        rank: 12
      },
      {
        value: 'KC',
        rank: 13
      },
      {
        value: 'AC',
        rank: 14
      },
      {
        value: '2S',
        rank: 2
      },
      {
        value: '3S',
        rank: 3
      },
      {
        value: '4S',
        rank: 4
      },
      {
        value: '5S',
        rank: 5
      },
      {
        value: '6S',
        rank: 6
      },
      {
        value: '7S',
        rank: 7
      },
      {
        value: '8S',
        rank: 8
      },
      {
        value: '9S',
        rank: 9
      },
      {
        value: '0S',
        rank: 10
      },
      {
        value: 'JS',
        rank: 11
      },
      {
        value: 'QS',
        rank: 12
      },
      {
        value: 'KS',
        rank: 13
      },
      {
        value: 'AS',
        rank: 14
      },
      {
        value: '2D',
        rank: 2
      },
      {
        value: '3D',
        rank: 3
      },
      {
        value: '4D',
        rank: 4
      },
      {
        value: '5D',
        rank: 5
      },
      {
        value: '6D',
        rank: 6
      },
      {
        value: '7D',
        rank: 7
      },
      {
        value: '8D',
        rank: 8
      },
      {
        value: '9D',
        rank: 9
      },
      {
        value: '0D',
        rank: 10
      },
      {
        value: 'JD',
        rank: 11
      },
      {
        value: 'QD',
        rank: 12
      },
      {
        value: 'KD',
        rank: 13
      },
      {
        value: 'AD',
        rank: 14
      }
    ];
    return myNewDeck;
  };

  deck = getNewDeck();

  // CARD LOGIC
  dealCards = function() {
    var cardId;
    if (heroIsDealer) {
      hero_image.classList.add("glowing");
    } else {
      villain_image.classList.add("glowing");
    }
    currentStreet++;
    // Villain cards
    villainCards = [];
    cardId = Math.floor(Math.random() * deck.length);
    villainCards.push(deck[cardId]);
    deck.splice(cardId, 1);
    cardId = Math.floor(Math.random() * deck.length);
    villainCards.push(deck[cardId]);
    deck.splice(cardId, 1);
    // Hero cards
    heroCards = [];
    cardId = Math.floor(Math.random() * deck.length);
    heroCards.push(deck[cardId]);
    deck.splice(cardId, 1);
    cardId = Math.floor(Math.random() * deck.length);
    heroCards.push(deck[cardId]);
    deck.splice(cardId, 1);
    return renderPlayerCards();
  };

  dealNextStreet = function(currentStreet) {
    if (heroIsDealer) {
      villain_image.classList.add("glowing");
    } else {
      hero_image.classList.add("glowing");
    }
    if (currentStreet === 1) {
      dealFlop();
      return renderButtons(0);
    } else if (currentStreet === 2) {
      renderButtons(0);
      return dealTurn();
    } else if (currentStreet === 3) {
      renderButtons(0);
      return dealRiver();
    } else if (currentStreet === 4) {
      button_bar.style.visibility = 'hidden';
      return endHand();
    }
  };

  dealFlop = function() {
    var card, cardId, i;
    currentStreet++;
    hero.clearCurrentBet();
    villain.clearCurrentBet();
    renderEmptyTableGraphics();
    // Villain act first OOP
    if (heroIsDealer) {
      setTimeout((function() {
        return villainAct();
      }), 800);
    } else {
      // hero act first
      button_bar.style.visibility = 'visible';
    }
    i = 3;
    while (i > 0) {
      cardId = Math.floor(Math.random() * deck.length);
      card = deck[cardId];
      board.push(card);
      deck.splice(cardId, 1);
      i--;
    }
    boardCard1.src = `assets/${board[0].value}.png`;
    boardCard2.src = `assets/${board[1].value}.png`;
    boardCard3.src = `assets/${board[2].value}.png`;
    console.log('flop dealet, det er ' + deck.length + ' kort igjen');
    return renderHandSrengths();
  };

  dealTurn = function() {
    var card, cardId;
    currentStreet++;
    hero.clearCurrentBet();
    villain.clearCurrentBet();
    renderEmptyTableGraphics();
    if (heroIsDealer) {
      villainAct();
    } else {
      button_bar.style.visibility = 'visible';
    }
    cardId = Math.floor(Math.random() * deck.length);
    card = deck[cardId];
    board.push(card);
    deck.splice(cardId, 1);
    boardCard4.src = `assets/${board[3].value}.png`;
    console.log('turn dealet, det er ' + deck.length + ' kort igjen');
    return renderHandSrengths();
  };

  dealRiver = function() {
    var card, cardId;
    currentStreet++;
    hero.clearCurrentBet();
    villain.clearCurrentBet();
    renderEmptyTableGraphics();
    if (heroIsDealer) {
      villainAct();
    } else {
      button_bar.style.visibility = 'visible';
    }
    cardId = Math.floor(Math.random() * deck.length);
    card = deck[cardId];
    board.push(card);
    deck.splice(cardId, 1);
    boardCard5.src = `assets/${board[4].value}.png`;
    console.log('river dealet, det er ' + deck.length + ' kort igjen');
    return renderHandSrengths();
  };

  endHand = function() {
    var amount, announcement, announcementHistory, heroHand, heroHandStrength, villainHand, villainHandStrength, winner;
    hero_image.classList.remove("glowing");
    villain_image.classList.remove("glowing");
    // show villain hand
    villainCard1DOM.src = `assets/${villainCards[0].value}.png`;
    villainCard2DOM.src = `assets/${villainCards[1].value}.png`;
    villainStrength.style.display = "";
    villainStrength.style.visibility = "visible";
    villainStrength.style.display = "";
    // get players hand strength
    villainHand = getHandStrength(villainCards, board, 'villain');
    heroHand = getHandStrength(heroCards, board, 'hero');
    // convert hand strength from string to int
    // hand strengths output as integer
    villainHandStrength = handRank(villainHand);
    heroHandStrength = handRank(heroHand);
    // declare winner
    if (heroHandStrength > villainHandStrength) {
      winner = 'Hero';
      announcement = 'Hero wins ' + potSize + '$';
      announcementHistory = 'You win ' + potSize + '$ with ' + heroHand;
      hero.winsPot();
    } else if (heroHandStrength < villainHandStrength) {
      winner = 'Villain';
      announcement = 'Villain wins ' + potSize + ' $';
      announcementHistory = 'Villain wins ' + potSize + '$ with ' + villainHand;
      villain.winsPot();
    } else {
      // hero wins on kicker
      // split pot
      if (heroCardsInteger[1] > villainCardsInteger[1]) {
        winner = 'Hero';
        announcement = 'Hero wins ' + potSize + '$';
        announcementHistory = 'You win ' + potSize + '$ with ' + villainHand;
        hero.winsPot();
      // villain wins on kicker
      } else if (heroCardsInteger[1] < villainCardsInteger[1]) {
        winner = 'Villain';
        announcement = 'Villain wins ' + potSize + ' $';
        announcementHistory = 'Villain wins ' + potSize + '$ with ' + villainHand;
        villain.winsPot();
      } else {
        //split
        winner = 'Split';
        announcement = 'Split pot ';
        announcementHistory = 'Split pot ';
        amount = potSize / 2;
        hero.stackSize += amount;
        villain.stackSize += amount;
      }
    }
    setTimeout((function() {
      return new_hand_btn.style.display = "block";
    }), 1500);
    // show end of hand text
    historyBox.scrollIntoView(false);
    emptyTableForAnnouncementText();
    announcementText.innerHTML = announcement;
    hero_current_bet.style.visibility = "hidden";
    button_bar.style.display = "none";
    heroIsDealer = !heroIsDealer;
    // history-box
    historyBox = document.getElementById('history');
    p = document.createElement("p");
    p.innerHTML = announcementHistory;
    p.classList.add('history-text');
    historyBox.append(p);
    return historyBox.scrollIntoView(false);
  };

  
  // GET HAND-STRENGTH INFORMATION

  getHandStrength = function(playerCards, board, player) {
    var card, hand, handStrengths, index, k, l, len, len1, len2, m, rank, strength, string, string1, string2, string3, string4, string5, strongestHand;
    handStrengths = [''];
    strongestHand = [''];
    rank = 0;
    // get the hand
    hand = [];
    for (k = 0, len = playerCards.length; k < len; k++) {
      card = playerCards[k];
      hand.push(card);
    }
    for (l = 0, len1 = board.length; l < len1; l++) {
      card = board[l];
      hand.push(card);
    }
    // check for all hand strengths
    handStrengths.push(hasFlush(hand));
    handStrengths.push(hasRankedBasedHand(hand, player));
    handStrengths.push(hasStraight(hand));
// return the strongest one
    for (index = m = 0, len2 = handStrengths.length; m < len2; index = ++m) {
      strength = handStrengths[index];
      if (handStrengths[index].includes('Four')) {
        rank = 9;
        strongestHand = [];
        strongestHand.push(handStrengths[index]);
      } else if (strength.includes('house')) {
        if (rank < 8) {
          rank = 8;
          strongestHand = [];
          strongestHand.push(handStrengths[index]);
        }
      } else if (strength.includes('Flush')) {
        if (rank < 7) {
          rank = 7;
          strongestHand = [];
          strongestHand.push(handStrengths[index]);
        }
      } else if (strength.includes('Straight')) {
        if (rank < 6) {
          rank = 6;
          strongestHand = [];
          strongestHand.push(handStrengths[index]);
        }
      } else if (strength.includes('Three')) {
        if (rank < 5) {
          rank = 5;
          strongestHand = [];
          strongestHand.push(handStrengths[index]);
        }
      } else if (strength.includes('Two')) {
        if (rank < 4) {
          rank = 4;
          strongestHand = [];
          strongestHand.push(handStrengths[index]);
        }
      } else if (strength.includes('Pair')) {
        if (rank < 3) {
          rank = 3;
          strongestHand = [];
          strongestHand.push(handStrengths[index]);
        }
      } else if (strength.includes('High card')) {
        if (rank < 2) {
          rank = 2;
          strongestHand = [];
          strongestHand.push(handStrengths[index]);
        }
      }
    }
    string = strongestHand[0];
    string1 = string.replace("10", "Ten");
    string2 = string1.replace("11", "Jack");
    string3 = string2.replace("12", "Queen");
    string4 = string3.replace("13", "King");
    string5 = string4.replace("14", "Ace");
    return string5;
  };

  // determine winning hand at end (rank by integers)
  handRank = function(hand) {
    if (hand.includes('Four')) {
      return 9;
    } else if (hand.includes('Full')) {
      return 8;
    } else if (hand.includes('Flush')) {
      return 7;
    } else if (hand.includes('Straight')) {
      return 6;
    } else if (hand.includes('Three')) {
      return 5;
    } else if (hand.includes('Two')) {
      return 4;
    } else if (hand.includes('Pair')) {
      return 3;
    } else if (hand.includes('High')) {
      return 2;
    }
  };

  // kicker for ranked type hands
  getKicker = function(ranks) {
    var j, kicker;
    j = ranks.length;
    while (j > 0) {
      kicker = '';
      if (ranks[j - 1] === 1) {
        kicker = j + 1;
        return kicker;
        j = 0;
      }
      j--;
    }
  };

  hasFlush = function(hand) {
    var card, index, k, kicker, l, len, len1, len2, len3, len4, m, n, o, rank, ranks, suits;
    suits = {
      hearts: 0,
      spades: 0,
      clubs: 0,
      diamonds: 0
    };
    ranks = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0 // used to track high cards
    ];

    // push suits in hand to new array
    for (index = k = 0, len = hand.length; k < len; index = ++k) {
      card = hand[index];
      if (card.value.includes('H')) {
        suits.hearts += 1;
      } else if (card.value.includes('C')) {
        suits.clubs += 1;
      } else if (card.value.includes('D')) {
        suits.diamonds += 1;
      } else if (card.value.includes('S')) {
        suits.spades += 1;
      }
    }
    // check for flush
    if (suits.hearts >= 5) {
      for (l = 0, len1 = hand.length; l < len1; l++) {
        card = hand[l];
        if (card.value.includes('H')) {
          rank = card.rank;
          // place the card rank in the array with same index. Card '4H' gets placed in the fourth element-> rank[3]
          ranks[rank - 2] += 1;
          kicker = getKicker(ranks);
        }
      }
      return 'Flush in Hearts' + ', ' + kicker + ' high';
    } else if (suits.clubs >= 5) {
      for (m = 0, len2 = hand.length; m < len2; m++) {
        card = hand[m];
        if (card.value.includes('C')) {
          rank = card.rank;
          ranks[rank - 2] += 1;
          kicker = getKicker(ranks);
        }
      }
      return 'Flush in clubs' + ', ' + kicker + ' high';
    } else if (suits.diamonds >= 5) {
      for (n = 0, len3 = hand.length; n < len3; n++) {
        card = hand[n];
        if (card.value.includes('D')) {
          rank = card.rank;
          ranks[rank - 2] += 1;
          kicker = getKicker(ranks);
        }
      }
      return 'Flush in diamonds' + ', ' + kicker + ' high';
    } else if (suits.spades >= 5) {
      for (o = 0, len4 = hand.length; o < len4; o++) {
        card = hand[o];
        if (card.value.includes('S')) {
          rank = card.rank;
          ranks[rank - 2] += 1;
          kicker = getKicker(ranks);
        }
      }
      return 'Flush in spades' + ', ' + kicker + ' high';
    } else {
      return ' ';
    }
  };

  hasRankedBasedHand = function(hand, player) {
    var card, highCard, i, index, k, kicker, l, len, len1, outcome, pair, pair1, pair2, pairs, quads, rank, ranks, trips, value;
    // these arrays keeps track of hand strengths registered
    quads = [];
    trips = [];
    pairs = [];
    ranks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
// check every card in hand
    for (k = 0, len = hand.length; k < len; k++) {
      card = hand[k];
      rank = card.rank;
      // place the card rank in the array with same index. Card '4H' gets placed in the fourth element-> rank[3]
      ranks[rank - 2] += 1;
    }
// check for how many of same
    for (index = l = 0, len1 = ranks.length; l < len1; index = ++l) {
      value = ranks[index];
      //index+1 IS ALSO EQUAL to the card rank
      if (value === 2) {
        pairs.push(index + 1);
      } else if (value === 3) {
        trips.push(index + 1);
      } else if (value === 4) {
        quads.push(index + 1);
      }
    }
    kicker = getKicker(ranks);
    
    // no pair (high card)
    if (pairs.length === 0 && quads.length === 0 && trips.length === 0) {
      i = ranks.length;
      while (i >= 0) {
        if (ranks[i] > 0) {
          highCard = i + 2;
          if (player === 'hero') {
            heroCardsInteger = [2, highCard];
          } else {
            villainCardsInteger = [2, highCard];
          }
          return 'High card ' + highCard;
        } else {

        }
        i--;
      }
    // ONE PAIR
    } else if (pairs.length === 1 && trips.length === 0 && quads.length === 0) {
      if (player === 'hero') {
        heroCardsInteger = [3, pairs[0]];
      } else {
        villainCardsInteger = [3, pairs[0]];
      }
      // the actual pair
      pairs[0] += 1;
      return 'Pair of ' + pairs[0].toString() + ', ' + kicker + ' kicker';
    // two pair
    } else if (pairs.length === 2) {
      pair1 = pairs[0] + 1;
      pair2 = pairs[1] + 1;
      if (player === 'hero') {
        heroCardsInteger = [4, pair2];
      } else {
        villainCardsInteger = [4, pair2];
      }
      outcome = "Two pairs: " + pair1 + ' and ' + pair2 + '. ' + ' kicker ' + kicker;
      return outcome;
    // three pair
    } else if (pairs.length === 3) {
      pair1 = pairs[0] + 1;
      pair2 = pairs[1] + 1;
      if (player === 'hero') {
        heroCardsInteger = [4, pair1];
      } else {
        heroCardsInteger = [4, pair1];
      }
      outcome = "Two pairs " + pair1 + ' and ' + pair2 + ', ' + kicker + ' kicker';
      return outcome;
    }
    // trips
    if (trips.length === 1) {
      if (pairs.length === 0) {
        card = trips[0] + 1;
        if (player === 'hero') {
          heroCardsInteger = [5, card.rank];
        } else {
          heroCardsInteger = [5, card.rank];
        }
        return 'Three of a kind ' + card + ', ' + kicker + ' kicker';
      }
      // full house
      if (pairs.length === 1) {
        pair = pairs[0] + 1;
        trips = trips[0] + 1;
        outcome = 'Full house ' + trips + '' + trips + '' + trips + ' and ' + pair + '' + pair;
        return outcome;
      }
    }
    // quads
    if (quads.length === 1) {
      outcome = "Four of a kind " + (quads[0] + 1).toString();
      return outcome;
    }
  };

  hasStraight = function(hand) {
    var card, index, k, kicker, l, len, len1, rank, ranks;
    ranks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
// place every card in correct order
    for (k = 0, len = hand.length; k < len; k++) {
      card = hand[k];
      rank = card.rank;
      ranks[rank - 2] += 1;
    }
// loop cards
    for (index = l = 0, len1 = ranks.length; l < len1; index = ++l) {
      card = ranks[index];
      // no straight if 3 cards of same value
      if (ranks[index] === 3) {

      } else if (ranks[index] > 0) {
        if (ranks[index + 1] > 0 && ranks[index + 2] > 0 && ranks[index + 3] > 0 && ranks[index + 4] > 0) {
          kicker = getKicker(ranks);
          kicker = kicker.toString();
          return 'Straight '; //+ kicker + ' high'
        } else {
          return '';
        }
      }
    }
  };

  
  // RENDERING #

  // bruker denne kun på river. Gjør det manuelt på earlier streets (different changes)
  emptyTableForAnnouncementText = function() {
    hero_current_action.style.visibility = "hidden";
    villainActing.style.visibility = "hidden";
    villain_current_bet.style.visibility = 'hidden';
    hero_dealer.style.visibility = "hidden";
    villain_dealer.style.visibility = "hidden";
    return announcementText.style.visibility = "visible";
  };

  renderBets = function() {
    var heroBet, villainBet;
    heroBet = hero.getCurrentBet();
    villainBet = villain.getCurrentBet();
    // hero
    if (heroBet === 0) {
      hero_current_bet.innerHTML = '';
    } else {
      hero_current_bet.innerHTML = '$' + heroBet;
    }
    // villain
    if (villainBet === 0) {
      if (villain_current_bet.text = 'Check') {

      } else {
        return villain_current_bet.innerHTML = '';
      }
    } else {
      return villain_current_bet.innerHTML = '$' + villainBet;
    }
  };

  // villain rendering
  renderVillainFoldText = function() {
    return villainActing.innerHTML = 'Fold';
  };

  renderVillainCheckText = function() {
    return villainActing.innerHTML = 'Check';
  };

  renderVillainCallText = function() {
    return villainActing.innerHTML = 'Call ';
  };

  renderVillainBetText = function() {
    return villainActing.innerHTML = 'Bet ';
  };

  
  // hero rendering
  renderHeroCheckText = function() {
    return hero_current_action.innerHTML = 'Check';
  };

  renderHeroCallText = function() {
    return hero_current_action.innerHTML = 'Call';
  };

  renderHeroBetText = function() {
    return hero_current_action.innerHTML = 'Check';
  };

  // reset table graphics
  renderEmptyTableGraphics = function() {
    renderButtons(0);
    hero.clearCurrentBet();
    villain.clearCurrentBet();
    hero_current_action.innerHTML = '';
    return villainActing.innerHTML = '';
  };

  renderEmptyHeroCards = function() {
    heroCard1DOM.src = 'assets/empty.png';
    return heroCard2DOM.src = 'assets/empty.png';
  };

  renderEmptyVillainCards = function() {
    villainCard1DOM.src = 'assets/empty.png';
    return villainCard2DOM.src = 'assets/empty.png';
  };

  renderPot = function(amount) {
    return potDOM.innerHTML = 'Pot: $' + amount;
  };

  renderButtons = function(facingBet) {
    // facing no bet
    if (facingBet === 0) {
      fold_btn.innerHTML = 'Fold';
      check_call_btn.innerHTML = 'Check';
      return bet_raise_btn.innerHTML = 'Bet $' + (facingBet + 100);
    // facing small blind
    } else if (facingBet === 25) {
      fold_btn.innerHTML = 'Fold';
      check_call_btn.innerHTML = 'Call $' + facingBet;
      return bet_raise_btn.innerHTML = 'Raise $' + 100;
    } else {
      // facing bet
      fold_btn.innerHTML = 'Fold';
      check_call_btn.innerHTML = 'Call $' + (facingBet - hero.getCurrentBet());
      return bet_raise_btn.innerHTML = 'Raise $' + (facingBet * 2);
    }
  };

  renderStacks = function() {
    var heroStackSize, villainStackSize;
    heroStackSize = hero.getStackSize().toLocaleString();
    villainStackSize = villain.getStackSize().toLocaleString();
    heroStack.innerHTML = '$' + heroStackSize;
    return villainStack.innerHTML = '$' + villainStackSize;
  };

  clearBets = function() {
    hero_current_bet.innerHTML = '';
    return villain_current_bet.innerHTML = '';
  };

  renderDealerBtn = function(player) {
    if (player === 'hero') {
      hero_dealer.style.visibility = "visible";
      return villain_dealer.style.visibility = "hidden";
    } else if (player === 'villain') {
      hero_dealer.style.visibility = "hidden";
      return villain_dealer.style.visibility = "visible";
    }
  };

  renderResetFlop = function() {
    boardCard1.src = "";
    boardCard2.src = "";
    boardCard3.src = "";
    boardCard4.src = "";
    return boardCard5.src = "";
  };

  renderPlayerCards = function() {
    //render villain vards
    villainCard1DOM.src = "assets/purple_back.png";
    villainCard2DOM.src = "assets/purple_back.png";
    //render Hero cards
    return setTimeout((function() {
      heroCard1DOM.src = `assets/${heroCards[0].value}.png`;
      return heroCard2DOM.src = `assets/${heroCards[1].value}.png`;
    }), 250);
  };

  renderHandSrengths = function() {
    heroStrength.innerHTML = getHandStrength(heroCards, board);
    return villainStrength.innerHTML = getHandStrength(villainCards, board);
  };

  
  // VILLAIN LOGIC (ACTIONS) #

  villainCreateAndMakeBet = function(betAmount) {
    villainActing.innerHTML = 'Bet ';
    hero_current_action.innerHTML = '';
    villain.bets(betAmount);
    renderBets();
    renderButtons(betAmount);
    // history-box
    historyBox = document.getElementById('history');
    p = document.createElement("p");
    p.innerHTML = 'Villain bets ' + betAmount + '$';
    p.classList.add('history-text', 'red');
    historyBox.append(p);
    return historyBox.scrollIntoView(false);
  };

  villainFold = function() {
    renderEmptyVillainCards();
    renderVillainFoldText();
    // history-box
    historyBox = document.getElementById('history');
    p = document.createElement("p");
    p.innerHTML = 'Villain folds';
    p.classList.add('history-text', 'red');
    historyBox.append(p);
    historyBox.scrollIntoView(false);
    button_bar.style.visibility = 'hidden';
    return setTimeout((function() {
      hero.winsPot();
      // reset stuff for new hand
      currentStreet = 0;
      deck = getNewDeck();
      heroIsDealer = !heroIsDealer;
      // end of hand text
      emptyTableForAnnouncementText();
      hero_current_action.innerHTML = 'Fold';
      announcementText.innerHTML = 'Hero wins: ' + potSize + '$';
      return setTimeout((function() {
        return startHand();
      }), 1500);
    }), 1500);
  };

  
  //###############

  //   VILLAIN BOT 

  //###############
  villainAct = function() {
    var hideHeroActionBar, isVillainDealer, rand, villainActTime;
    villain_image.classList.add("glowing");
    hero_image.classList.remove("glowing");
    historyBox.scrollIntoView(false);
    // render graphics
    renderStacks();
    button_bar.style.visibility = 'hidden';
    villainActing.style.visibility = "visible";
    setTimeout((function() {
      return villainActing.innerHTML = 'Acting..';
    }), 350);
    hideHeroActionBar = false;
    isVillainDealer = !heroIsDealer;
    rand = Math.floor(Math.random() * (100 - 13)) + 13;
    // rand = 80
    console.log(rand);
    villainActTime = 1200;
    return setTimeout((function() {
      var betAmount, facingBet;
      
      // PRE-FLOP #

      facingBet = hero.getCurrentBet() - villain.getCurrentBet();
      if (currentStreet === 1) {
        facingBet = hero.getCurrentBet() - villain.getCurrentBet();
        // villain is dealer
        if (isVillainDealer) {
          // fold
          if (rand < 33) {
            villainFold();
            renderVillainFoldText();
            hideHeroActionBar = true;
          
          // call
          } else if (rand > 33 && rand < 66) {
            // villain only calls small blind
            if (facingBet === 25) {
              villain.calls(25);
              // history-box
              historyBox = document.getElementById('history');
              p = document.createElement("p");
              p.innerHTML = 'Villain calls ' + 25 + '$';
              p.classList.add('history-text', 'red');
              historyBox.append(p);
              historyBox.scrollIntoView(false);
              renderVillainCallText();
              renderButtons(0);
            // villain calls a raise -> next street
            } else if (facingBet > 25) {
              villain.calls(facingBet);
              // history-box
              historyBox = document.getElementById('history');
              p = document.createElement("p");
              p.innerHTML = 'Villain calls ' + facingBet + '$';
              p.classList.add('history-text', 'red');
              historyBox.append(p);
              historyBox.scrollIntoView(false);
              renderVillainCallText();
              hideHeroActionBar = true;
              setTimeout((function() {
                return dealNextStreet(currentStreet);
              }), villainActTime);
            }
            renderVillainCallText();
          // raise
          } else if (rand > 66) {
            betAmount = hero.getCurrentBet() * 1.5;
            villainCreateAndMakeBet(betAmount);
            renderButtons(betAmount);
          }
        } else {
          // react to Hero call blind
          // villain not dealer
          if (hero.getCurrentBet() === 50) {
            if (rand <= 50) {
              renderVillainCheckText();
              hideHeroActionBar = true;
              setTimeout((function() {
                return dealNextStreet(currentStreet);
              }), villainActTime);
            } else if (rand > 50) {
              betAmount = hero.getCurrentBet() + 50;
              villainCreateAndMakeBet(betAmount);
              renderButtons(betAmount);
            }
          }
          // faces raise
          if (hero.getCurrentBet() > 50) {
            // fold to raise
            if (rand < 33) {
              villainFold();
              renderVillainFoldText();
              hideHeroActionBar = true;
            }
            // call
            if (rand > 33 && rand < 66) {
              villain.calls(hero.getCurrentBet() - villain.getCurrentBet());
              // history-box
              historyBox = document.getElementById('history');
              p = document.createElement("p");
              p.innerHTML = 'Villain calls ' + facingBet + '$';
              p.classList.add('history-text', 'red');
              historyBox.append(p);
              historyBox.scrollIntoView(false);
              renderVillainCallText();
              hideHeroActionBar = true;
              setTimeout((function() {
                return dealNextStreet(currentStreet);
              }), villainActTime);
            
            // raise
            } else if (rand > 66) {
              betAmount = hero.getCurrentBet() * 1.5;
              villainCreateAndMakeBet(betAmount);
              renderButtons(betAmount);
            }
          }
        }
      //#
      // FLOP ###############
      //#
      } else if (currentStreet === 2) {
        // facing check
        if (hero.getCurrentBet() === 0) {
          if (rand < 33) {
            // villain check -> next street if dealer
            renderVillainCheckText();
            if (!heroIsDealer) {
              hideHeroActionBar = true;
              setTimeout((function() {
                return dealNextStreet(currentStreet);
              }), villainActTime);
            }
          // villain bet small
          } else if (rand > 33 && rand < 66) {
            betAmount = hero.getCurrentBet();
            betAmount += 100;
            villainCreateAndMakeBet(betAmount);
            renderButtons(betAmount);
          // villain bet big
          } else if (rand > 66) {
            betAmount = hero.getCurrentBet() + 100;
            villainCreateAndMakeBet(betAmount);
            renderButtons(betAmount);
          }
        } else {
          
          // fold
          // villain faces bet flop
          if (rand < 33) {
            villainFold();
            renderVillainFoldText();
            hideHeroActionBar = false;
          } else if (rand < 66) {
            // CALL
            villain.calls(hero.getCurrentBet() - villain.getCurrentBet());
            
            // history-box
            historyBox = document.getElementById('history');
            p = document.createElement("p");
            p.innerHTML = 'Villain calls ' + facingBet + '$';
            p.classList.add('history-text', 'red');
            historyBox.append(p);
            historyBox.scrollIntoView(false);
            renderVillainCallText();
            hideHeroActionBar = true;
            setTimeout((function() {
              return dealNextStreet(currentStreet);
            }), villainActTime);
          } else {
            
            // RAISE
            betAmount = hero.getCurrentBet() * 1.5;
            villainCreateAndMakeBet(betAmount);
            renderButtons(betAmount);
          }
        }
      //#
      // TURN #####################
      //#
      } else if (currentStreet === 3) {
        // facing no bet
        if (hero.getCurrentBet() === 0) {
          // CHECK
          if (rand < 33) {
            renderVillainCheckText();
            if (!heroIsDealer) {
              hideHeroActionBar = true;
              setTimeout((function() {
                return dealNextStreet(currentStreet);
              }), villainActTime);
            }
          // call
          } else if (rand < 66) {
            betAmount = hero.getCurrentBet();
            betAmount += 100;
            villainCreateAndMakeBet(betAmount);
            renderButtons(betAmount);
          // bet
          } else if (rand > 66) {
            betAmount = 100;
            villainCreateAndMakeBet(betAmount);
            renderButtons(betAmount);
          }
        } else {
          
          // fold
          // villain faces bet turn
          if (rand < 33) {
            villainFold();
            renderVillainFoldText();
            hideHeroActionBar = false;
          // call
          } else if (rand < 66) {
            villain.calls(hero.getCurrentBet() - villain.getCurrentBet());
            // history-box
            historyBox = document.getElementById('history');
            p = document.createElement("p");
            p.innerHTML = 'Villain calls ' + facingBet + '$';
            p.classList.add('history-text', 'red');
            historyBox.append(p);
            historyBox.scrollIntoView(false);
            renderVillainCallText();
            hideHeroActionBar = true;
            setTimeout((function() {
              return dealNextStreet(currentStreet);
            }), villainActTime);
          // raise
          } else if (rand > 66) {
            betAmount = hero.getCurrentBet() * 1.5;
            villainCreateAndMakeBet(betAmount);
            renderButtons(betAmount);
          }
        }
      
      // RIVER #####################

      } else if (currentStreet === 4) {
        // facing no bet
        if (hero.getCurrentBet() === 0) {
          // check
          if (rand < 33) {
            if (!heroIsDealer) {
              hideHeroActionBar = true;
              setTimeout((function() {
                return dealNextStreet(currentStreet);
              }), villainActTime);
            // check to hero if OOP
            } else if (heroIsDealer) {
              renderVillainCheckText();
            }
          // small bet
          } else if (rand > 33 && rand < 66) {
            betAmount = hero.getCurrentBet();
            betAmount += 100;
            villainCreateAndMakeBet(betAmount);
            renderButtons(betAmount);
          // big bet
          } else if (rand > 66) {
            betAmount = hero.getCurrentBet();
            betAmount += 200;
            villainCreateAndMakeBet(betAmount);
            renderButtons(betAmount);
          }
        // facing bet
        } else if (hero.getCurrentBet() > 0) {
          facingBet = hero.getCurrentBet() - villain.getCurrentBet();
          // fold
          if (rand < 33) {
            villainFold();
            renderVillainFoldText();
            hideHeroActionBar = true;
          // call
          } else if (rand < 66) {
            villain.calls(facingBet);
            // history-box
            historyBox = document.getElementById('history');
            p = document.createElement("p");
            p.innerHTML = 'Villain calls ' + facingBet + '$';
            p.classList.add('history-text', 'red');
            historyBox.append(p);
            historyBox.scrollIntoView(false);
            renderVillainCallText();
            hideHeroActionBar = true;
            // call as dealer -> next street
            setTimeout((function() {
              return dealNextStreet(currentStreet);
            }), villainActTime);
          // raise
          } else if (rand > 66) {
            betAmount = hero.getCurrentBet() * 1.5;
            villainCreateAndMakeBet(betAmount);
            renderButtons(betAmount);
          }
        }
      }
      
      // This always runs after villain acts
      villain_image.classList.remove("glowing");
      historyBox.scrollIntoView(false);
      renderStacks();
      if (hideHeroActionBar) {
        return button_bar.style.visibility = 'hidden';
      } else {
        return setTimeout((function() {
          button_bar.style.visibility = 'visible';
          return hero_image.classList.add("glowing");
        }), 600);
      }
    }), 2200); //total act time
  };

  
  // HERO BUTTONS (ACTION LOGIC) #

  // FOLD BUTTON LOGIC
  heroFold = function() {
    hero_image.classList.remove("glowing");
    // reset stuff for new hand
    historyBox.scrollIntoView(false);
    renderEmptyHeroCards();
    button_bar.style.visibility = 'hidden';
    return setTimeout((function() {
      villain.winsPot();
      currentStreet = 0;
      deck = getNewDeck();
      heroIsDealer = !heroIsDealer;
      // history-box
      historyBox = document.getElementById('history');
      p = document.createElement("p");
      p.innerHTML = 'You fold';
      p.classList.add('history-text');
      historyBox.append(p);
      historyBox.scrollIntoView(false);
      // end of hand text
      emptyTableForAnnouncementText();
      hero_current_action.innerHTML = 'Fold';
      announcementText.innerHTML = 'Villain wins: ' + potSize + '$';
      announcementText.style.visibility = "visible";
      return setTimeout((function() {
        return startHand();
      }), 1500);
    }), 500);
  };

  
  // BET/RAISE BUTTON LOGIC

  betRaise = function() {
    var amount;
    hero_image.classList.remove("glowing");
    // the betsize sum inlcudes the players bet already on table. This gets adjusted in Player.bet()
    historyBox.scrollIntoView(false);
    amount = villain.getCurrentBet();
    if (amount <= 50) {
      amount = 100;
    } else {
      amount *= 2;
    }
    hero_current_action.innerHTML = '';
    // history-box
    historyBox = document.getElementById('history');
    p = document.createElement("p");
    p.innerHTML = 'You bet ' + amount + '$';
    p.classList.add('history-text');
    historyBox.append(p);
    historyBox.scrollIntoView(false);
    hero.bets(amount);
    renderBets();
    return villainAct();
  };

  
  // CHECK/CALL BUTTON LOGIC

  checkCall = function() {
    var facingBet;
    hero_image.classList.remove("glowing");
    historyBox.scrollIntoView(false);
    facingBet = villain.getCurrentBet() - hero.getCurrentBet();
    historyBox = document.getElementById('history');
    p = document.createElement("p");
    if (facingBet === 0) {
      p.innerHTML = 'You check';
    } else {
      p.innerHTML = 'You call ' + facingBet + '$';
    }
    p.classList.add('history-text');
    historyBox.append(p);
    historyBox.scrollIntoView(false);
    // dealer preflop
    if (currentStreet === 1 && heroIsDealer) {
      
      // call SB 
      if (facingBet === 25) {
        hero.calls(25);
        villainAct();
      // calling raise 
      } else if (facingBet > 25) {
        hero.calls(facingBet);
        setTimeout((function() {
          return dealNextStreet(currentStreet);
        }), 1000);
      }
    // not dealer preflop
    } else if (currentStreet === 1 && !heroIsDealer) {
      hero.calls(facingBet);
      // calls a bet
      if (facingBet > 0) {
        hero_current_action.innerHTML = '';
        setTimeout((function() {
          return dealNextStreet(currentStreet);
        }), 1000);
      // checking BB
      } else if (facingBet <= 50) {
        //renderHeroCheckText()
        setTimeout((function() {
          return dealNextStreet(currentStreet);
        }), 1000);
      }
    } else {
      
      // check/call IP -> always next street

      // check/call postflop
      if (heroIsDealer) {
        // facing check
        if (facingBet === 0) {
          setTimeout((function() {
            return dealNextStreet(currentStreet);
          }), 1000);
        // facing bet
        } else if (facingBet > 0) {
          hero.calls(facingBet);
          setTimeout((function() {
            return dealNextStreet(currentStreet);
          }), 1000);
        }
      // check to villain
      } else if (facingBet === 0) {
        hero.calls(facingBet);
        villainAct();
      // call a bet -> next street
      } else if (facingBet > 0) {
        hero.calls(facingBet);
        hero_current_action.innerHTML = '';
        setTimeout((function() {
          return dealNextStreet(currentStreet);
        }), 1000);
      }
    }
    button_bar.style.visibility = 'hidden';
    return renderBets();
  };

  // Hero ACTION buttons
  fold_btn.addEventListener('click', heroFold);

  check_call_btn.addEventListener('click', checkCall);

  bet_raise_btn.addEventListener('click', betRaise);

  
  // CREATE PLAYER CLASSES

  Player = class Player {
    constructor(stackSize, currentBet) {
      this.stackSize = stackSize;
      this.currentBet = currentBet;
    }

    paySmallBlind() {
      this.stackSize -= 25;
      return this.currentBet = 25;
    }

    payBigBlind() {
      this.stackSize -= 50;
      return this.currentBet = 50;
    }

    getStackSize() {
      return this.stackSize;
    }

    getCurrentBet() {
      return this.currentBet;
    }

    setCurrentBet(amount) {
      return this.currentBet = amount;
    }

    clearCurrentBet() {
      this.currentBet = 0;
      return clearBets();
    }

    winsPot() {
      this.stackSize += potSize;
      return renderStacks();
    }

    // the betsize sum inlcudes the players bet already on table. Adjusting this here
    bets(amount) {
      var prevBet;
      prevBet = this.currentBet;
      this.currentBet = amount;
      this.stackSize -= amount - prevBet;
      potSize += amount - prevBet;
      renderPot(potSize);
      return renderStacks();
    }

    // the call sum inlcudes the players bet already on table. Adjusting this here
    calls(amount) {
      this.currentBet += amount;
      this.stackSize -= amount;
      potSize += amount;
      renderPot(potSize);
      renderStacks();
      return renderBets();
    }

  };

  hero = new Player(defaultStackSize, 0);

  villain = new Player(defaultStackSize, 0);

  startHand = function() {
    // reset stuff for new hand
    table_logo.style.opacity = "1";
    historyBox.scrollIntoView(false);
    new_hand_btn.innerHTML = "Next Hand";
    announcementText.innerHTML = '';
    villainActing.innerHTML = '';
    hero_current_action.innerHTML = '';
    hero_current_bet.innerHTML = '';
    villain_current_bet.innerHTML = '';
    potDOM.innerHTML = '';
    hero_current_action.innerHTML = '';
    announcementText.innerHTML = '';
    heroStrength.innerHTML = '';
    villainStrength.innerHTML = '';
    villainStrength.style.visibility = 'hidden';
    villainStrength.style.display = 'none';
    hero_current_action.style.visibility = 'visible';
    hero_current_bet.style.visibility = 'visible';
    villain_current_bet.style.visibility = 'visible';
    announcementText.style.visibility = "hidden";
    new_hand_btn.style.display = 'none';
    button_bar.style.display = "block";
    button_bar.style.display = "flex";
    board = [];
    renderEmptyHeroCards();
    renderEmptyVillainCards();
    renderResetFlop();
    currentStreet = 0;
    deck = getNewDeck();
    
    // history-box
    historyBox = document.getElementById('history');
    p = document.createElement("p");
    handTracker += 1;
    p.innerHTML = '---- Hand #' + handTracker + ' ----';
    p.classList.add('history-text', 'grey');
    historyBox.append(p);
    historyBox.scrollIntoView(false);
    
    // deal cards
    historyBox.scrollIntoView(false);
    return setTimeout((function() {
      potSize = 3;
      potDOM.innerHTML = 'Pot: $' + potSize;
      // Pay blinds
      if (heroIsDealer) {
        renderDealerBtn('hero');
        hero.paySmallBlind();
        villain.payBigBlind();
        renderBets();
        setTimeout((function() {
          renderButtons(villain.getCurrentBet() - hero.getCurrentBet());
          return button_bar.style.visibility = 'visible';
        }), 2000);
        renderStacks();
      } else if (!heroIsDealer) {
        renderDealerBtn('villain');
        button_bar.style.visibility = 'hidden';
        hero.payBigBlind();
        villain.paySmallBlind();
        renderBets();
        setTimeout((function() {
          return villainAct();
        }), 2000);
      }
      // pay blinds
      return setTimeout((function() {
        return dealCards();
      }), 1000);
    }), 1000);
  };

  new_hand_btn.addEventListener('click', startHand);

  //startHand()

  // SIMULATE HANDS
// heroCards = [ deck[0], deck[1] ]
// board = [ deck[2], deck[3], deck[6], deck[19], deck[32] ]
// hand1 = [ deck[2], deck[3], deck[18], deck[45], deck[30], deck[0], deck[1] ]
// heroStrength = getHandStrength(heroCards, board)
// console.log heroCards
// console.log board
// console.log 'heros hand strength: ' + heroStrength

}).call(this);
